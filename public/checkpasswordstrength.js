!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).checkPasswordStrength = {}) }(this, (function (e) { "use strict"; function t(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var n = { exports: {} }; const i = [{ id: 0, value: "Too weak", minDiversity: 0, minLength: 0 }, { id: 1, value: "Weak", minDiversity: 2, minLength: 6 }, { id: 2, value: "Medium", minDiversity: 4, minLength: 8 }, { id: 3, value: "Strong", minDiversity: 4, minLength: 10 }], s = (e, t = i, n = "!\"#$%&'()*+,-./:;<=>?@[\\\\\\]^_`{|}~") => { let s = e || ""; t[0].minDiversity = 0, t[0].minLength = 0; const r = [{ regex: "[a-z]", message: "lowercase" }, { regex: "[A-Z]", message: "uppercase" }, { regex: "[0-9]", message: "number" }]; n && r.push({ regex: `[${n}]`, message: "symbol" }); let o = {}; o.contains = r.filter((e => new RegExp(`${e.regex}`).test(s))).map((e => e.message)), o.length = s.length; let a = t.filter((e => o.contains.length >= e.minDiversity)).filter((e => o.length >= e.minLength)).sort(((e, t) => t.id - e.id)).map((e => ({ id: e.id, value: e.value }))); return Object.assign(o, a[0]), o }; n.exports = { passwordStrength: s, defaultOptions: i }; var r = n.exports.passwordStrength = s, o = n.exports.defaultOptions = i, a = t(n.exports); e.default = a, e.defaultOptions = o, e.passwordStrength = r, Object.defineProperty(e, "__esModule", { value: !0 }) }));